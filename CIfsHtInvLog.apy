-----------------------------------------------------------------------------
--
--  Logical unit: CIfsHtInvLog
--
--  Purpose:
--
--  IFS/Design Template Version 2.5
--
--  Date    Sign    History
--  ------  ------  ---------------------------------------------------------
-----------------------------------------------------------------------------

DEFINE MODULE        = ORDER
DEFINE LU            = CIfsHtInvLog
DEFINE TABLE         = C_IFS_HT_INV_LOG_TAB
DEFINE VIEW          = C_IFS_HT_INV_LOG
DEFINE VIEW1         = C_IFS_HT_INV_LOG_HEAD
DEFINE PKG           = C_IFS_HT_INV_LOG_API

DEFINE OBJID         = rowid
DEFINE OBJVERSION    = "ltrim(lpad(to_char(rowversion,'YYYYMMDDHH24MISS'),2000))"

-----------------------------------------------------------------------------
-------------------- VIEWS FOR SELECTS --------------------------------------
-----------------------------------------------------------------------------

PROMPT Creating &VIEW view

CREATE OR REPLACE VIEW &VIEW AS
/*SELECT  sequ_id						  sequ_id,		
		serial_no					  serial_no,		
		company						  company,
		company_api.Get_Name(company) company_name,
		billing_document			  billing_document,				
		custid						  custid,
		C_IFS_HT_INVOIVE_API.Get_Custid_Name(company,custid) cust_name,
		TO_DATE(TO_CHAR(billing_date, 'YYYY-MM-DD HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS')		
									  billing_date,	
        TO_DATE(TO_CHAR(pricing_date, 'YYYY-MM-DD HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS')											  
									  pricing_date,							
		net_vat_amount				  net_vat_amount,				
		tax_numner					  tax_numner,		
		address						  address,					
		bank_account				  bank_account,				
		remark						  remark,	
		remark1						  remark1,
		remark2						  remark2,
		 C_IFS_HT_TRANSFER_CODE_API.Decode(state)        state,
		operate_user				  operate_user,	
        TO_DATE(TO_CHAR(operate_date, 'YYYY-MM-DD HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS')			
									  operate_date,				  		
		count						  count,	
		amount_diff					  amount_diff,		
		send_flg					  send_flg,		
		&OBJID                        objid,
        &OBJVERSION                   objversion							
FROM    c_ifs_ht_inv_log_tab
WITH   read only;*/
select *
  from (select sequ_id sequ_id,
               serial_no serial_no,
               company company,
               company_api.Get_Name(company) company_name,
               billing_document billing_document,
               custid custid,
               C_IFS_HT_INVOIVE_API.Get_Custid_Name(company, custid) cust_name,
               TO_DATE(TO_CHAR(billing_date, 'YYYY-MM-DD HH24:MI:SS'),
                       'YYYY-MM-DD HH24:MI:SS') billing_date,
               TO_DATE(TO_CHAR(pricing_date, 'YYYY-MM-DD HH24:MI:SS'),
                       'YYYY-MM-DD HH24:MI:SS') pricing_date,
               net_vat_amount net_vat_amount,
               tax_numner tax_numner,
               address address,
               bank_account bank_account,
               remark remark,
               remark1 remark1,
               remark2 remark2,
               C_IFS_HT_TRANSFER_CODE_API.Decode(state) state,
               operate_user operate_user,
               TO_DATE(TO_CHAR(operate_date, 'YYYY-MM-DD HH24:MI:SS'),
                       'YYYY-MM-DD HH24:MI:SS') operate_date,
               count count,
               amount_diff amount_diff,
               send_flg send_flg,
               rowid objid,
               ltrim(lpad(to_char(rowversion, 'YYYYMMDDHH24MISS'), 2000)) objversion,
               row_number() over(partition by a.company, a.custid, a.serial_no, a.billing_document order by sequ_id desc) rn
          from C_IFS_HT_INV_LOG_tab a WHERE A.STATE<>'6') t1
 where rn = 1;

COMMENT ON TABLE &VIEW
   IS 'LU=&LU^PROMPT=C Ifs Ht Inv Log^MODULE=&MODULE^';

COMMENT ON COLUMN &VIEW..sequ_id
   IS 'FLAGS=AMI-L^DATATYPE=NUMBER^PROMPT=Sequ Id^';
COMMENT ON COLUMN &VIEW..serial_no
   IS 'FLAGS=KMI-L^DATATYPE=STRING(100)^PROMPT=Serial No^';
COMMENT ON COLUMN &VIEW..company
   IS 'FLAGS=KMI-L^DATATYPE=STRING(5)^PROMPT=Company^';
COMMENT ON COLUMN &VIEW..company_name
   IS 'FLAGS=KMI-L^DATATYPE=STRING(100)^PROMPT=Company Name^';
COMMENT ON COLUMN &VIEW..billing_document
   IS 'FLAGS=KMI-L^DATATYPE=STRING(12)^PROMPT=Billing Document^';
COMMENT ON COLUMN &VIEW..custid
   IS 'FLAGS=KMI-L^DATATYPE=STRING(20)^PROMPT=Custid^';
COMMENT ON COLUMN &VIEW..cust_name
   IS 'FLAGS=KMI-L^DATATYPE=STRING(100)^PROMPT=Cust Name^';
COMMENT ON COLUMN &VIEW..billing_date
   IS 'FLAGS=KMI-L^DATATYPE=DATE/DATE^PROMPT=Billing Date^';
COMMENT ON COLUMN &VIEW..pricing_date
   IS 'FLAGS=A-I-L^DATATYPE=DATE/DATE^PROMPT=Pricing Date^';
COMMENT ON COLUMN &VIEW..net_vat_amount
   IS 'FLAGS=A-IUL^DATATYPE=NUMBER^PROMPT=Net Vat Amount^';
COMMENT ON COLUMN &VIEW..tax_numner
   IS 'FLAGS=A-IUL^DATATYPE=STRING(20)^PROMPT=Tax Numner^';
COMMENT ON COLUMN &VIEW..address
   IS 'FLAGS=A-IUL^DATATYPE=STRING(200)^PROMPT=Address^';
COMMENT ON COLUMN &VIEW..bank_account
   IS 'FLAGS=A-IUL^DATATYPE=STRING(100)^PROMPT=Bank Account^';
COMMENT ON COLUMN &VIEW..remark
   IS 'FLAGS=A-IUL^DATATYPE=STRING(200)^PROMPT=Remark^';
COMMENT ON COLUMN &VIEW..remark1
   IS 'FLAGS=A-IUL^DATATYPE=STRING(200)^PROMPT=Remark1^';
COMMENT ON COLUMN &VIEW..remark2
   IS 'FLAGS=A-IUL^DATATYPE=STRING(200)^PROMPT=Remark2^';
COMMENT ON COLUMN &VIEW..state
   IS 'FLAGS=A-IUL^DATATYPE=STRING(1)^PROMPT=State^';
COMMENT ON COLUMN &VIEW..operate_user
   IS 'FLAGS=A-IUL^DATATYPE=STRING(30)^PROMPT=Operate User^'; 
COMMENT ON COLUMN &VIEW..operate_date
   IS 'FLAGS=A-I-L^DATATYPE=DATE/DATE^PROMPT=Operate Date^';
COMMENT ON COLUMN &VIEW..count
   IS 'FLAGS=A-IUL^DATATYPE=NUMBER^PROMPT=Count^';
COMMENT ON COLUMN &VIEW..amount_diff
   IS 'FLAGS=A-IUL^DATATYPE=NUMBER^PROMPT=Amount Diff^';
COMMENT ON COLUMN &VIEW..send_flg
   IS 'FLAGS=A-IUL^DATATYPE=STRING(2)^PROMPT=Send Flg^';
   
   
CREATE OR REPLACE VIEW &VIEW1 AS
SELECT
	sequ_id             		  sequ_id,
    serial_no           		  serial_no,
	company						  company,
    company_api.Get_Name(company) company_name,
	billing_document    		  billing_document,
	custid						  custid,
    C_IFS_HT_INVOIVE_API.Get_Custid_Name(company,custid) cust_name,
	C_IFS_HT_INV_LOG_ALL_API.Get_Custid_PartQty_Sum(company,custid,sequ_id) total_qty,
	C_IFS_HT_INV_LOG_ALL_API.Get_Custid_PartNet_Sum(company,custid,sequ_id) total_net_value,
	C_IFS_HT_INV_LOG_ALL_API.Get_Custid_PartVat_Sum(company,custid,sequ_id) total_vat_value,
	C_IFS_HT_INV_LOG_ALL_API.Get_Custid_PartTol_Sum(company,custid,sequ_id) net_vat_amount,
    &OBJID                        objid,
    &OBJVERSION                   objversion
FROM   c_ifs_ht_inv_log_tab
WHERE   STATE<>'6'
WITH   read only;

COMMENT ON COLUMN &VIEW1..sequ_id
   IS 'FLAGS=AMI-L^DATATYPE=NUMBER^PROMPT=Sequ Id^';
COMMENT ON COLUMN &VIEW1..serial_no
   IS 'FLAGS=KMI-L^DATATYPE=STRING(100)^PROMPT=Serial No^';
COMMENT ON COLUMN &VIEW1..company
   IS 'FLAGS=KMI-L^DATATYPE=STRING(5)^PROMPT=Company^';
COMMENT ON COLUMN &VIEW1..company_name
   IS 'FLAGS=KMI-L^DATATYPE=STRING(100)^PROMPT=Company Name^';
COMMENT ON COLUMN &VIEW1..billing_document
   IS 'FLAGS=KMI-L^DATATYPE=STRING(12)^PROMPT=Billing Document^';
COMMENT ON COLUMN &VIEW1..custid
   IS 'FLAGS=KMI-L^DATATYPE=STRING(20)^PROMPT=Custid^';
COMMENT ON COLUMN &VIEW1..cust_name
   IS 'FLAGS=KMI-L^DATATYPE=STRING(100)^PROMPT=Cust Name^';
COMMENT ON COLUMN &VIEW1..total_qty
   IS 'FLAGS=KMI-L^DATATYPE=NUMBER^PROMPT=Total Qty^';
COMMENT ON COLUMN &VIEW1..total_net_value
   IS 'FLAGS=KMI-L^DATATYPE=NUMBER^PROMPT=Total Net Value^';
COMMENT ON COLUMN &VIEW1..total_vat_value
   IS 'FLAGS=KMI-L^DATATYPE=NUMBER^PROMPT=Total Vat Value^';
COMMENT ON COLUMN &VIEW1..net_vat_amount
   IS 'FLAGS=KMI-L^DATATYPE=NUMBER^PROMPT=Net Vat Amount^';
-----------------------------------------------------------------------------
-------------------- PACKAGES FOR METHODS -----------------------------------
-----------------------------------------------------------------------------

PROMPT Creating &PKG implementation

CREATE OR REPLACE PACKAGE BODY &PKG IS

-----------------------------------------------------------------------------
-------------------- LU SPECIFIC IMPLEMENTATION METHOD DECLARATIONS ---------
-----------------------------------------------------------------------------


-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS ----------------------------
-----------------------------------------------------------------------------
-- Lock_By_Id___
--    Client-support to lock a specific instance of the logical unit.
--
-- Lock_By_Keys___
--    Server support to lock a specific instance of the logical unit.
--
-- Get_Object_By_Id___
--    Get LU-record from the database with a specified object identity.
--
-- Get_Object_By_Keys___
--    Get LU-record from the database with specified key columns.
--
-- Check_Exist____
--    Check if a specific LU-instance already exist in the database.
--
-- Get_Id_Version_By_Keys___
--    Get the current OBJID and OBJVERSION for a specific LU-instance.
-----------------------------------------------------------------------------

FUNCTION Lock_By_Id___ (
   objid_      IN VARCHAR2,
   objversion_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   row_changed EXCEPTION;
   row_deleted EXCEPTION;
   row_locked  EXCEPTION;
   PRAGMA      EXCEPTION_INIT(row_locked, -0054);
   rec_        &TABLE%ROWTYPE;
   dummy_      NUMBER;
   CURSOR lock_control IS
      SELECT *
      FROM   &TABLE
      WHERE  &OBJID = objid_
      AND    &OBJVERSION = objversion_
      FOR UPDATE NOWAIT;
   CURSOR exist_control IS
      SELECT 1
      FROM   &TABLE
      WHERE  &OBJID = objid_;
BEGIN
   OPEN lock_control;
   FETCH lock_control INTO rec_;
   IF (lock_control%FOUND) THEN
      CLOSE lock_control;
      RETURN rec_;
   END IF;
   CLOSE lock_control;
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RAISE row_changed;
   ELSE
      CLOSE exist_control;
      RAISE row_deleted;
   END IF;
EXCEPTION
   WHEN row_locked THEN
      Error_SYS.Record_Locked(lu_name_);
   WHEN row_changed THEN
      Error_SYS.Record_Modified(lu_name_);
   WHEN row_deleted THEN
      Error_SYS.Record_Removed(lu_name_);
END Lock_By_Id___;


FUNCTION Lock_By_Keys___ (
   sequ_id_  IN NUMBER,
   serial_no_  IN VARCHAR2,
   billing_document_    IN VARCHAR2) RETURN C_IFS_HT_INV_LOG_TAB%ROWTYPE
IS
   row_deleted EXCEPTION;
   rec_        C_IFS_HT_INV_LOG_TAB%ROWTYPE;
   CURSOR lock_control IS
      SELECT *
      FROM   C_IFS_HT_INV_LOG_TAB
      WHERE  sequ_id = sequ_id_
		    AND	 serial_no = serial_no_
		    AND	 billing_document = billing_document_
      FOR UPDATE;
BEGIN
   OPEN lock_control;
   FETCH lock_control INTO rec_;
   IF (lock_control%FOUND) THEN
      CLOSE lock_control;
      RETURN rec_;
   ELSE
      CLOSE lock_control;
      RAISE row_deleted;
   END IF;
EXCEPTION
   WHEN row_deleted THEN
      Error_SYS.Record_Removed(lu_name_);
END Lock_By_Keys___;


FUNCTION Get_Object_By_Id___ (
   objid_ IN VARCHAR2 ) RETURN &TABLE%ROWTYPE
IS
   lu_rec_ &TABLE%ROWTYPE;
   CURSOR getrec IS
      SELECT *
      FROM   &TABLE
      WHERE  &OBJID = objid_;
BEGIN
   OPEN getrec;
   FETCH getrec INTO lu_rec_;
   IF (getrec%NOTFOUND) THEN
      CLOSE getrec;
      Error_SYS.Record_Removed(lu_name_);
   END IF;
   CLOSE getrec;
   RETURN(lu_rec_);
END Get_Object_By_Id___;


FUNCTION Get_Object_By_Keys___ (
   sequ_id_  IN NUMBER,
   serial_no_  IN VARCHAR2,
   billing_document_    IN VARCHAR2) RETURN &TABLE%ROWTYPE
IS
   lu_rec_ &TABLE%ROWTYPE;
   CURSOR getrec IS
      SELECT *
      FROM   &TABLE
      WHERE  sequ_id = sequ_id_ 
		AND	 serial_no = serial_no_  
		AND	 billing_document = billing_document_ ;
BEGIN
   OPEN getrec;
   FETCH getrec INTO lu_rec_;
   CLOSE getrec;
   RETURN(lu_rec_);
END Get_Object_By_Keys___;


FUNCTION Check_Exist____ (
   sequ_id_  IN NUMBER,
   serial_no_  IN VARCHAR2,
   billing_document_    IN VARCHAR2) RETURN BOOLEAN
IS
   dummy_ NUMBER;
   CURSOR exist_control IS
      SELECT 1
      FROM   &TABLE
      WHERE  sequ_id = sequ_id_ 
		AND	 serial_no_ = serial_no_  
		AND	 billing_document = billing_document_ ;
BEGIN
   OPEN exist_control;
   FETCH exist_control INTO dummy_;
   IF (exist_control%FOUND) THEN
      CLOSE exist_control;
      RETURN(TRUE);
   END IF;
   CLOSE exist_control;
   RETURN(FALSE);
END Check_Exist____;


PROCEDURE Get_Id_Version_By_Keys___ (
   objid_      IN OUT VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   sequ_id_    IN NUMBER,
   serial_no_  IN VARCHAR2,
   billing_document_    IN VARCHAR2)
IS
   CURSOR get_version IS
      SELECT &OBJID, &OBJVERSION
      FROM   &TABLE
      WHERE  sequ_id = sequ_id_ 
		AND	 serial_no = serial_no_  
		AND	 billing_document = billing_document_;
BEGIN
   OPEN get_version;
   FETCH get_version INTO objid_, objversion_;
   CLOSE get_version;
END Get_Id_Version_By_Keys___;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS FOR INSERT -----------------
-----------------------------------------------------------------------------
-- Prepare_Insert___
--    Set all default values for a new instance (ON-NEW-RECORD) of this
--    logical unit by calling procedure Add_Attr.
--
-- Unpack_Check_Insert___
--    Unpack the attribute list, check all attributes from the client
--    and generate all default values before creation of the new object.
--
-- Insert___
--    Insert a new LU-instance into the database and return the values
--    for OBJID and OBJVERSION.
-----------------------------------------------------------------------------

PROCEDURE Prepare_Insert___ (
   attr_ IN OUT VARCHAR2 )
IS
   seq_no_   NUMBER;
BEGIN
   Client_SYS.Clear_Attr(attr_);
   SELECT C_IFS_HT_LOG_SEQ.nextval INTO seq_no_ FROM DUAL;
   Client_SYS.Add_To_Attr('SEQU_ID',seq_no_ , attr_);
END Prepare_Insert___;


PROCEDURE Unpack_Check_Insert___ (
   attr_   IN OUT VARCHAR2,
   newrec_ IN OUT &TABLE%ROWTYPE )
IS
   ptr_   NUMBER;
   name_  VARCHAR2(30);
   value_ VARCHAR2(4000);
BEGIN
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      IF (name_ = 'SEQU_ID') THEN
         newrec_.sequ_id := Client_SYS.Attr_Value_To_Number(value_);
	  ELSIF (name_ = 'SERIAL_NO') THEN
         newrec_.serial_no := value_;
      ELSIF (name_ = 'COMPANY') THEN
         newrec_.company := value_;
      ELSIF (name_ = 'BILLING_DOCUMENT') THEN
         newrec_.billing_document := value_;
	  ELSIF (name_ = 'CUSTID') THEN
         newrec_.custid := value_;
      ELSIF (name_ = 'BILLING_DATE') THEN
         newrec_.billing_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'PRICING_DATE') THEN
         newrec_.pricing_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'NET_VAT_AMOUNT') THEN
         newrec_.net_vat_amount := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'TAX_NUMNER') THEN
         newrec_.tax_numner := value_;
      ELSIF (name_ = 'ADDRESS') THEN
         newrec_.address := value_;
      ELSIF (name_ = 'BANK_ACCOUNT') THEN
         newrec_.bank_account := value_;
      ELSIF (name_ = 'REMARK') THEN
         newrec_.remark := value_;
	  ELSIF (name_ = 'STATE') THEN
         newrec_.state := value_;
	  ELSIF (name_ = 'OPERATE_USER') THEN
         newrec_.operate_user := value_;
	  ELSIF (name_ = 'OPERATE_DATE') THEN
         newrec_.operate_date := Client_SYS.Attr_Value_To_Date(value_);
	  ELSIF (name_ = 'COUNT') THEN
         newrec_.count := Client_SYS.Attr_Value_To_Number(value_);
	  ELSIF (name_ = 'AMOUNT_DIFF') THEN
         newrec_.amount_diff := Client_SYS.Attr_Value_To_Number(value_);
	  ELSIF (name_ = 'SEND_FLG') THEN
         newrec_.send_flg := value_;
      ELSE
         Error_SYS.Item_Not_Exist(lu_name_, name_, value_);
      END IF;
   END LOOP;
   Client_SYS.Clear_Attr(attr_);
   Error_SYS.Check_Not_Null(lu_name_, 'SEQU_ID', newrec_.sequ_id);
   Error_SYS.Check_Not_Null(lu_name_, 'SERIAL_NO', newrec_.serial_no);
   Error_SYS.Check_Not_Null(lu_name_, 'COMPANY', newrec_.company);
   Error_SYS.Check_Not_Null(lu_name_, 'BILLING_DOCUMENT', newrec_.billing_document);
   Error_SYS.Check_Not_Null(lu_name_, 'CUSTID', newrec_.custid);
   Error_SYS.Check_Not_Null(lu_name_, 'BILLING_DATE', newrec_.billing_date);
   Error_SYS.Check_Not_Null(lu_name_, 'NET_VAT_AMOUNT', newrec_.net_vat_amount);
   Error_SYS.Check_Not_Null(lu_name_, 'TAX_NUMNER', newrec_.tax_numner);
   Error_SYS.Check_Not_Null(lu_name_, 'ADDRESS', newrec_.address);
   Error_SYS.Check_Not_Null(lu_name_, 'BANK_ACCOUNT', newrec_.bank_account);
   Error_SYS.Check_Not_Null(lu_name_, 'STATE', newrec_.state);
   Error_SYS.Check_Not_Null(lu_name_, 'OPERATE_USER', newrec_.operate_user);
   Error_SYS.Check_Not_Null(lu_name_, 'OPERATE_DATE', newrec_.operate_date);
    
EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Unpack_Check_Insert___;


PROCEDURE Insert___ (
   objid_      OUT    VARCHAR2,
   objversion_ OUT    VARCHAR2,
   newrec_     IN OUT &TABLE%ROWTYPE,
   attr_       IN OUT VARCHAR2 )
IS
BEGIN
   newrec_.rowversion := sysdate;
   INSERT
      INTO c_ifs_ht_inv_log_tab (
	    sequ_id,							
		serial_no,							
		company,						
		billing_document,							
		custid,							
		billing_date,							
		pricing_date,							
		net_vat_amount,							
		tax_numner,							
		address,							
		bank_account,							
		remark,							
		state,							
		operate_user,							
		operate_date,							
		count,							
		amount_diff,							
		send_flg,							
		rowversion							
		)
      VALUES (
         newrec_.sequ_id,							
		 newrec_.serial_no,							
		 newrec_.company,						
		 newrec_.billing_document,							
		 newrec_.custid,							
		 newrec_.billing_date,							
		 newrec_.pricing_date,							
		 newrec_.net_vat_amount,							
		 newrec_.tax_numner,							
		 newrec_.address,							
		 newrec_.bank_account,							
		 newrec_.remark,							
		 newrec_.state,							
		 newrec_.operate_user,							
		 newrec_.operate_date,							
		 newrec_.count,							
		 newrec_.amount_diff,							
		 newrec_.send_flg,							
         newrec_.rowversion)
      RETURNING &OBJID INTO objid_;
   objversion_ := to_char(newrec_.rowversion,'YYYYMMDDHH24MISS');
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Insert___;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS FOR UPDATE -----------------
-----------------------------------------------------------------------------
-- Unpack_Check_Update___
--    Unpack the attribute list, check all attributes from the client
--    and generate all default values before modifying the object.
--
-- Update___
--    Update an existing LU-instance in the database and return the
--    the new OBJVERSION.
-----------------------------------------------------------------------------

PROCEDURE Unpack_Check_Update___ (
   attr_   IN OUT VARCHAR2,
   newrec_ IN OUT &TABLE%ROWTYPE,
   objid_  IN     VARCHAR2 )
IS
   ptr_   NUMBER;
   name_  VARCHAR2(30);
   value_ VARCHAR2(4000);

BEGIN
   ptr_ := NULL;
   WHILE (Client_SYS.Get_Next_From_Attr(attr_, ptr_, name_, value_)) LOOP
      IF (name_ = 'SEQU_ID') THEN
         newrec_.sequ_id := Client_SYS.Attr_Value_To_Number(value_);
	  ELSIF (name_ = 'SERIAL_NO') THEN
         newrec_.serial_no := value_;
      ELSIF (name_ = 'COMPANY') THEN
         newrec_.company := value_;
      ELSIF (name_ = 'BILLING_DOCUMENT') THEN
         newrec_.billing_document := value_;
	  ELSIF (name_ = 'CUSTID') THEN
         newrec_.custid := value_;
      ELSIF (name_ = 'BILLING_DATE') THEN
         newrec_.billing_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'PRICING_DATE') THEN
         newrec_.pricing_date := Client_SYS.Attr_Value_To_Date(value_);
      ELSIF (name_ = 'NET_VAT_AMOUNT') THEN
         newrec_.net_vat_amount := Client_SYS.Attr_Value_To_Number(value_);
      ELSIF (name_ = 'TAX_NUMNER') THEN
         newrec_.tax_numner := value_;
      ELSIF (name_ = 'ADDRESS') THEN
         newrec_.address := value_;
      ELSIF (name_ = 'BANK_ACCOUNT') THEN
         newrec_.bank_account := value_;
      ELSIF (name_ = 'REMARK') THEN
         newrec_.remark := value_;
	  ELSIF (name_ = 'STATE') THEN
         newrec_.state := value_;
	  ELSIF (name_ = 'OPERATE_USER') THEN
         newrec_.operate_user := value_;
	  ELSIF (name_ = 'OPERATE_DATE') THEN
         newrec_.operate_date := Client_SYS.Attr_Value_To_Date(value_);
	  ELSIF (name_ = 'COUNT') THEN
         newrec_.count := Client_SYS.Attr_Value_To_Number(value_);
	  ELSIF (name_ = 'AMOUNT_DIFF') THEN
         newrec_.amount_diff := Client_SYS.Attr_Value_To_Number(value_);
	  ELSIF (name_ = 'SEND_FLG') THEN
         newrec_.send_flg := value_;
          ELSIF (name_ = 'REMARK1') THEN
	 newrec_.remark1 := value_;
	 ELSIF (name_ = 'REMARK2') THEN
	 newrec_.remark2 := value_;
      ELSE
         Error_SYS.Item_Not_Exist(lu_name_, name_, value_);
      END IF;
   END LOOP;
   Client_SYS.Clear_Attr(attr_);
EXCEPTION
   WHEN value_error THEN
      Error_SYS.Item_Format(lu_name_, name_, value_);
END Unpack_Check_Update___;


PROCEDURE Update___ (
   objid_      IN     VARCHAR2,
   oldrec_     IN     &TABLE%ROWTYPE,
   newrec_     IN OUT &TABLE%ROWTYPE,
   attr_       IN OUT VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   by_keys_    IN     BOOLEAN DEFAULT FALSE )
IS
BEGIN
   newrec_.rowversion := sysdate;
   IF by_keys_ THEN
      UPDATE c_ifs_ht_inv_log_tab
        SET sequ_id = newrec_.sequ_id,							
			serial_no = newrec_.serial_no,							
			company = newrec_.company,						
			billing_document = newrec_.billing_document,							
			custid = newrec_.custid,							
			billing_date = newrec_.billing_date,							
			pricing_date = newrec_.pricing_date,							
			net_vat_amount = newrec_.net_vat_amount,							
			tax_numner = newrec_.tax_numner,							
			address = newrec_.address,							
			bank_account = newrec_.bank_account,							
			remark = newrec_.remark,
			remark1 = newrec_.remark1,
			remark2 = newrec_.remark2,
			state = newrec_.state,							
			operate_user = newrec_.operate_user,							
			operate_date = newrec_.operate_date,							
			count = newrec_.count,							
			amount_diff = newrec_.amount_diff,							
			send_flg = newrec_.send_flg,							
			rowversion = newrec_.rowversion
        WHERE sequ_id = newrec_.sequ_id
		  AND serial_no = newrec_.serial_no  
		  AND billing_document = newrec_.billing_document;
   ELSE
      UPDATE c_ifs_ht_inv_log_tab
        SET sequ_id = newrec_.sequ_id,							
			serial_no = newrec_.serial_no,							
			company = newrec_.company,						
			billing_document = newrec_.billing_document,							
			custid = newrec_.custid,							
			billing_date = newrec_.billing_date,							
			pricing_date = newrec_.pricing_date,							
			net_vat_amount = newrec_.net_vat_amount,							
			tax_numner = newrec_.tax_numner,							
			address = newrec_.address,							
			bank_account = newrec_.bank_account,							
			remark = newrec_.remark,
			remark1 = newrec_.remark1,
			remark2 = newrec_.remark2,
			state = newrec_.state,							
			operate_user = newrec_.operate_user,							
			operate_date = newrec_.operate_date,							
			count = newrec_.count,							
			amount_diff = newrec_.amount_diff,							
			send_flg = newrec_.send_flg,							
			rowversion = newrec_.rowversion
        WHERE &OBJID = objid_;
   END IF;
   objversion_ := to_char(newrec_.rowversion,'YYYYMMDDHH24MISS');
EXCEPTION
   WHEN dup_val_on_index THEN
      Error_SYS.Record_Exist(lu_name_);
END Update___;

-----------------------------------------------------------------------------
-------------------- IMPLEMENTATION BASE METHODS FOR DELETE -----------------
-----------------------------------------------------------------------------
-- Check_Delete___
--    Checks whether a specific LU-record may be removed or not.
--    The procedure should check business rules like attribute values
--    as well as database constraints (defined or not).
--
-- Delete___
--    Deletion of the specific LU-object from the database.
-----------------------------------------------------------------------------

PROCEDURE Check_Delete___ (
   remrec_ IN &TABLE%ROWTYPE )
IS
   key_ VARCHAR2(2000);
BEGIN
   key_ := remrec_.sequ_id || '^' ||remrec_.serial_no || '^' || remrec_.billing_document || '^' ;
   Reference_SYS.Check_Restricted_Delete(lu_name_, key_);
END Check_Delete___;


PROCEDURE Delete___ (
   objid_  IN VARCHAR2,
   remrec_ IN &TABLE%ROWTYPE )
IS
   key_ VARCHAR2(2000);
BEGIN
   key_ := remrec_.sequ_id || '^' ||remrec_.serial_no || '^' || remrec_.billing_document || '^' ;
   Reference_SYS.Do_Cascade_Delete(lu_name_, key_);
   DELETE
      FROM  &TABLE
      WHERE &OBJID = objid_;
END Delete___;

-----------------------------------------------------------------------------
-------------------- PRIVATE BASE METHODS -----------------------------------
-----------------------------------------------------------------------------
-- Lock__
--    Client-support to lock a specific instance of the logical unit.
--
-- New__
--    Client-support interface to create LU instances.
--       action_ = 'PREPARE'
--          Default values and handle of information to client.
--          The default values are set in procedure Prepare_Insert___.
--       action_ = 'CHECK'
--          Check all attributes before creating new object and handle of
--          information to client. The attribute list is unpacked, checked
--          and prepared (defaults) in procedure Unpack_Check_Insert___.
--       action_ = 'DO'
--          Creation of new instances of the logical unit and handle of
--          information to client. The attribute list is unpacked, checked
--          and prepared (defaults) in procedure Unpack_Check_Insert___
--          before calling procedure Insert___.
--
-- Modify__
--    Client-support interface to modify attributes for LU instances.
--       action_ = 'CHECK'
--          Check all attributes before modifying an existing object and
--          handle of information to client. The attribute list is unpacked,
--          checked and prepared(defaults) in procedure Unpack_Check_Update___.
--       action_ = 'DO'
--          Modification of an existing instance of the logical unit. The
--          procedure unpacks the attributes, checks all values before
--          procedure Update___ is called.
--
-- Remove__
--    Client-support interface to remove LU instances.
--       action_ = 'CHECK'
--          Check whether a specific LU-instance may be removed or not.
--          The procedure fetches the complete record by calling procedure
--          Get_Object_By_Id___. Then the check is made by calling procedure
--          Check_Delete___.
--       action_ = 'DO'
--          Remove an existing instance of the logical unit. The procedure
--          fetches the complete LU-record, checks for a delete and then
--          deletes the record by calling procedure Delete___.
-----------------------------------------------------------------------------

PROCEDURE Lock__ (
   info_       OUT VARCHAR2,
   objid_      IN  VARCHAR2,
   objversion_ IN  VARCHAR2 )
IS
   dummy_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Lock__');
   dummy_ := Lock_By_Id___(objid_, objversion_);
   info_ := Client_SYS.Get_All_Info;
END Lock__;


PROCEDURE New__ (
   info_       OUT    VARCHAR2,
   objid_      OUT    VARCHAR2,
   objversion_ OUT    VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   newrec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'New__');
   IF (action_ = 'PREPARE') THEN
      Prepare_Insert___(attr_);
   ELSIF (action_ = 'CHECK') THEN
      Unpack_Check_Insert___(attr_, newrec_);
   ELSIF (action_ = 'DO') THEN
      Unpack_Check_Insert___(attr_, newrec_);
      Insert___(objid_, objversion_, newrec_, attr_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END New__;


FUNCTION Get_Sequ_Id(
   serial_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ C_IFS_HT_TRANSFER_LINE.sequ_id%TYPE;
   CURSOR get_attr IS
      SELECT sequ_id
      FROM C_IFS_HT_TRANSFER_LINE_TAB
      WHERE SERIAL_NO = serial_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Sequ_Id;

-----------------------------------------------------------------------------
--Project Name:CKC HT Replace                                              --
--Explain     :Withdraw                                                    --
--Create User :jliu                                                        --
--Create Date :2018-11-21                                                  --
-----------------------------------------------------------------------------
PROCEDURE Withdraw (
   sequ_id_     IN NUMBER,
   serial_no_   IN VARCHAR2,
   billing_document_ IN  VARCHAR2)
IS
   key_           VARCHAR2(2000);
   info_          VARCHAR2(2000);
   objid_         VARCHAR2(2000);
   objversion_    VARCHAR2(2000);
   attr_          VARCHAR2(2000);
   company_       VARCHAR2(20);
   custid_        VARCHAR2(20);

  CURSOR get_log_data IS
      SELECT  rowid                                                      objid,
               ltrim(lpad(to_char(rowversion,'YYYYMMDDHH24MISS'),2000))   objversion,
        company , custid
        FROM c_ifs_ht_inv_log_tab f 
        WHERE SEQU_ID   = sequ_id_
        and SERIAL_NO = serial_no_
        and BILLING_DOCUMENT = billing_document_;
BEGIN

   OPEN get_log_data;
   FETCH get_log_data INTO objid_,objversion_,company_ ,custid_ ;
   CLOSE get_log_data;

   Client_sys.clear_attr(attr_);
   Client_sys.Add_To_attr('STATE','6',attr_);
   Modify__(info_,objid_,objversion_,attr_,'DO');
   Update_data_state(company_ , custid_ ,serial_no_,billing_document_,6);

END Withdraw;
-----------------------------------------------------------------------------
--Project Name:CKC HT Replace                                              --
--Explain     :Withdraw                                                    --
--Create User :jliu                                                        --
--Create Date :2018-11-21                                                  --
-----------------------------------------------------------------------------
PROCEDURE Withdraw (
   sequ_id_     IN NUMBER,
   serial_no_   IN VARCHAR2)
IS
   key_           VARCHAR2(2000);
   info_          VARCHAR2(2000);
   objid_         VARCHAR2(2000);
   objversion_    VARCHAR2(2000);
   attr_          VARCHAR2(2000);
   company_       VARCHAR2(20);
   custid_        VARCHAR2(20);

  CURSOR get_log_data IS
      SELECT    objid,
                objversion,
        company , custid,
        billing_document
        FROM c_ifs_ht_inv_log f 
        WHERE SERIAL_NO = serial_no_;
BEGIN

   FOR log_data IN get_log_data LOOP
       Client_sys.clear_attr(attr_);
       Client_sys.Add_To_attr('STATE','6',attr_);
       Modify__(info_,log_data.objid,log_data.objversion,attr_,'DO');
       Update_data_state(log_data.company , log_data.custid ,serial_no_,log_data.billing_document,6);
   END LOOP;

END Withdraw;

-----------------------------------------------------------------------------
--Project Name:CKC HT Replace                                              --
--Explain     :Update State                                                --
--Create User :jliu                                                        --
--Create Date :2018-10-26                                                  --
-----------------------------------------------------------------------------
PROCEDURE  Update_data_state(company_ IN VARCHAR2 , custid_ IN VARCHAR2,serial_nos_ IN VARCHAR2 ,billing_documents_ IN VARCHAR2 ,State_ IN VARCHAR2)
IS

     info_          VARCHAR2(2000);
     inv_head_objid_        VARCHAR2(2000);
     inv_head_objversion_   VARCHAR2(2000);
     inv_line_objid_        VARCHAR2(2000);
     inv_line_objversion_   VARCHAR2(2000);
     objid_                 VARCHAR2(2000);
     objversion_            VARCHAR2(2000);
     attr_         VARCHAR2(2000);
     sequ_id_      NUMBER;
     serial_no_    VARCHAR2(100);
     billing_document_   VARCHAR2(20);
     attrs_         VARCHAR2(2000);

     CURSOR get_inv_head_data IS
     SELECT    rowid                                                      objid,
               ltrim(lpad(to_char(rowversion,'YYYYMMDDHH24MISS'),2000))   objversion,
               serial_no , billing_document
        FROM C_IFS_HT_INVOIVE_TAB f
	      WHERE f.company =company_
	      AND  f.custid =custid_
	      AND  f.serial_no =serial_no_
	      AND  f.billing_document=billing_document_;

   CURSOR get_inv_line_data(company_ IN VARCHAR2 , serial_no_ IN VARCHAR2, billing_document_ IN VARCHAR2) IS
      SELECT   rowid                                                      objid,
               ltrim(lpad(to_char(rowversion,'YYYYMMDDHH24MISS'),2000))   objversion
        FROM C_IFS_HT_INVOIVE_LINE_TAB f
	      WHERE f.company =company_
	      AND  f.serial_no=serial_no_
        AND  f.billing_document=billing_document_;


  CURSOR get_Sale_head_data IS
      SELECT objid , objversion
        FROM C_IFS_HT_TRANSFER f
	      WHERE f.company =company_
	      AND  f.custid=custid_
        AND  f.SEQU_ID=sequ_id_;

  CURSOR get_Sale_line_data IS
      SELECT objid , objversion
        FROM C_IFS_HT_TRANSFER_LINE f
	     WHERE f.company =company_
	      AND  f.serial_no=serial_no_
        AND  f.billing_document=billing_document_;


  CURSOR get_Sale_Rm_data IS
      SELECT distinct f.objid , f.objversion,f.sequ_id
        FROM C_IFS_HT_TRANSFER_RM f,C_IFS_HT_TRANSFER_LINE h
	      WHERE f.company =company_
	      AND  f.serial_no=serial_no_
        AND  f.serial_no=h.serial_no
        AND  h.billing_document=billing_document_;




BEGIN
     serial_no_:= serial_nos_  ;
     billing_document_ :=billing_documents_;

     FOR inv_head_data IN get_inv_head_data LOOP

         inv_head_objid_ :=inv_head_data.objid;
         inv_head_objversion_ :=inv_head_data.objversion;
         serial_no_:=inv_head_data.serial_no;
         billing_document_:=inv_head_data.billing_document;

         Client_sys.clear_attr(attr_);
         Client_sys.Add_To_attr('STATE',State_,attr_);
         attrs_ :=attr_;

        --remove inv head
	     C_IFS_HT_INVOIVE_API.Modify__(info_ , inv_head_objid_ , inv_head_objversion_ ,attr_, 'DO');

	      FOR Sale_line_data IN get_Sale_line_data LOOP
           attr_:=attrs_;
           objid_ :=Sale_line_data.objid;
           objversion_:=Sale_line_data.objversion;
           C_IFS_HT_TRANSFER_LINE_API.Modify__(info_ , objid_ , objversion_ ,attr_, 'DO');

	       END LOOP;

	     FOR Sale_Rm_data IN get_Sale_Rm_data LOOP
           attr_:=attrs_;
           objid_ :=Sale_Rm_data.objid;
           objversion_:=Sale_Rm_data.objversion;
           sequ_id_ :=Sale_Rm_data.sequ_id;
           C_IFS_HT_TRANSFER_RM_API.Modify__(info_ , objid_ , objversion_ ,attr_, 'DO');

	     END LOOP;

      	FOR Sale_head_data IN get_Sale_head_data LOOP
           attr_:=attrs_;
           objid_ :=Sale_head_data.objid;
           objversion_:=Sale_head_data.objversion;
	   Client_sys.clear_attr(attr_);
           Client_sys.Add_To_attr('STATE','3',attr_);
           C_IFS_HT_TRANSFER_API.Modify__(info_ , objid_ , objversion_ ,attr_, 'DO');

	     END LOOP;
     END LOOP;
  EXCEPTION
   WHEN OTHERS THEN
     ROLLBACK;
END Update_data_state;
-----------------------------------------------------------------------------
--Project Name:CKC HT Replace                                              --
--Explain     :Get Serial Billing                                          --
--Create User :jliu                                                        --
--Create Date :2018-11-21                                                  --
-----------------------------------------------------------------------------
FUNCTION Get_Serial_Billing(
   serial_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ C_IFS_HT_TRANSFER_RM_TAB.BILLING_DOCUMENT%TYPE;
   CURSOR get_attr IS
      SELECT BILLING_DOCUMENT
      FROM C_IFS_HT_TRANSFER_RM_TAB
      WHERE SERIAL_NO = serial_no_;
BEGIN
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Serial_Billing;

-----------------------------------------------------------------------------
--Project Name:CKC HT Replace                                              --
--Explain     :Get Serial Billing                                          --
--Create User :jliu                                                        --
--Create Date :2018-11-21                                                  --
-----------------------------------------------------------------------------
FUNCTION Get_Serial_Count(
   serial_no_ IN VARCHAR2 ) RETURN VARCHAR2
IS
   temp_ NUMBER;
   CURSOR get_attr IS
      SELECT   count(*)
        FROM c_ifs_ht_inv_log f 
        WHERE SERIAL_NO = serial_no_;
BEGIN
   temp_:=0;
   OPEN get_attr;
   FETCH get_attr INTO temp_;
   CLOSE get_attr;
   RETURN temp_;
END Get_Serial_Count;


PROCEDURE Modify__ (
   info_       OUT    VARCHAR2,
   objid_      IN     VARCHAR2,
   objversion_ IN OUT VARCHAR2,
   attr_       IN OUT VARCHAR2,
   action_     IN     VARCHAR2 )
IS
   oldrec_ c_ifs_ht_inv_log_tab%ROWTYPE;
   newrec_ c_ifs_ht_inv_log_tab%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, 'C_IFS_HT_CUSTOMER_API', 'Modify__');
   IF (action_ = 'CHECK') THEN
      newrec_ := Get_Object_By_Id___(objid_);
      Unpack_Check_Update___(attr_, newrec_, objid_);
   ELSIF (action_ = 'DO') THEN
      oldrec_ := Lock_By_Id___(objid_, objversion_);
      newrec_ := oldrec_;
      Unpack_Check_Update___(attr_, newrec_, objid_);
      Update___(objid_, oldrec_, newrec_, attr_, objversion_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Modify__;


PROCEDURE Remove__ (
   info_       OUT VARCHAR2,
   objid_      IN  VARCHAR2,
   objversion_ IN  VARCHAR2,
   action_     IN  VARCHAR2 )
IS
   remrec_ &TABLE%ROWTYPE;
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Remove__');
   IF (action_ = 'CHECK') THEN
      remrec_ := Get_Object_By_Id___(objid_);
      Check_Delete___(remrec_);
   ELSIF (action_ = 'DO') THEN
      remrec_ := Lock_By_Id___(objid_, objversion_);
      Check_Delete___(remrec_);
      Delete___(objid_, remrec_);
   END IF;
   info_ := Client_SYS.Get_All_Info;
END Remove__;

-----------------------------------------------------------------------------
-------------------- PUBLIC BASE METHODS ------------------------------------
-----------------------------------------------------------------------------
-- Exist
--   Checks if given pointer (e.g. primary key) to an instance of this
--   logical unit exists. If not an exception will be raised.
-----------------------------------------------------------------------------

PROCEDURE Exist (
   sequ_id_  IN NUMBER,
   serial_no_  IN VARCHAR2,
   billing_document_   IN VARCHAR2)
IS
BEGIN
   General_SYS.Init_Method(lu_name_, '&PKG', 'Exist', TRUE);
   IF (NOT Check_Exist____(sequ_id_, serial_no_, billing_document_)) THEN
      Error_SYS.Record_Not_Exist(lu_name_);
   END IF;
END Exist;

-----------------------------------------------------------------------------
-------------------- FOUNDATION1 METHODS ------------------------------------
-----------------------------------------------------------------------------
-- Init
--   Dummy procedure that can be called at database startup to ensure that
--   this package is loaded into memory for performance reasons only.
-----------------------------------------------------------------------------

PROCEDURE Init
IS
BEGIN
   NULL;
END Init;




END &PKG;
/
SHOW ERROR


UNDEFINE MODULE
UNDEFINE LU
UNDEFINE TABLE
UNDEFINE VIEW
UNDEFINE PKG
UNDEFINE OBJID
UNDEFINE OBJVERSION
-----------------------------------------------------------------------------
